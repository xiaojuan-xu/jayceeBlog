(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{438:function(t,n,a){"use strict";a.r(n);var e=a(2),s=Object(e.a)({},(function(){var t=this,n=t._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"执行上下文栈"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#执行上下文栈"}},[t._v("#")]),t._v(" 执行上下文栈")]),t._v(" "),n("p",[n("strong",[t._v("原文链接："),n("a",{attrs:{href:"https://github.com/mqyqingfeng/Blog",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://github.com/mqyqingfeng/Blog"),n("OutboundLink")],1)])]),t._v(" "),n("h3",{attrs:{id:"顺序执行"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#顺序执行"}},[t._v("#")]),t._v(" 顺序执行？")]),t._v(" "),n("hr"),t._v(" "),n("p",[t._v("如果要问到 JavaScript 代码执行顺序的话，想必写过 JavaScript 的开发者都会有个直观的印象，那就是顺序执行，毕竟：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("var foo = function () {\n    console.log('foo1');\n}\n\nfoo();  // foo1\n\nvar foo = function () {\n    console.log('foo2');\n}\n\nfoo(); // foo2\n")])])]),n("p",[t._v("然而去看这段代码：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("\nfunction foo() {\n    console.log('foo1');\n}\n\nfoo();  // foo2\n\nfunction foo() {\n    console.log('foo2');\n}\n\nfoo(); // foo2\n\n")])])]),n("p",[t._v("打印的结果却是两个 foo2。")]),t._v(" "),n("p",[t._v("刷过面试题的都知道这是因为 JavaScript 引擎并非一行一行地分析和执行程序，而是一段一段地分析执行。当执行一段代码的时候，会进行一个“准备工作”，比如第一个例子中的变量提升，和第二个例子中的函数提升。")]),t._v(" "),n("p",[t._v("但是本文真正想让大家思考的是：这个“一段一段”中的“段”究竟是怎么划分的呢？")]),t._v(" "),n("p",[t._v("到底JavaScript引擎遇到一段怎样的代码时才会做“准备工作”呢？")]),t._v(" "),n("h3",{attrs:{id:"可执行代码"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#可执行代码"}},[t._v("#")]),t._v(" "),n("strong",[t._v("可执行代码")])]),t._v(" "),n("hr"),t._v(" "),n("p",[t._v("这就要说到 JavaScript 的可执行代码(executable code)的类型有哪些了？")]),t._v(" "),n("p",[t._v("其实很简单，就三种，全局代码、函数代码、eval代码。")]),t._v(" "),n("p",[t._v('举个例子，当执行到一个函数的时候，就会进行准备工作，这里的“准备工作”，让我们用个更专业一点的说法，就叫做"执行上下文(execution context)"。')]),t._v(" "),n("h3",{attrs:{id:"执行上下文栈-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#执行上下文栈-2"}},[t._v("#")]),t._v(" "),n("strong",[t._v("执行上下文栈")])]),t._v(" "),n("hr"),t._v(" "),n("p",[t._v("接下来问题来了，我们写的函数多了去了，如何管理创建的那么多执行上下文呢？")]),t._v(" "),n("p",[t._v("所以 JavaScript 引擎创建了执行上下文栈（Execution context stack，ECS）来管理执行上下文")]),t._v(" "),n("p",[t._v("为了模拟执行上下文栈的行为，让我们定义执行上下文栈是一个数组：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("ECStack = [];\n")])])]),n("p",[t._v("试想当 JavaScript 开始要解释执行代码的时候，最先遇到的就是全局代码，所以初始化的时候首先就会向执行上下文栈压入一个全局执行上下文，我们用 globalContext 表示它，并且只有当整个应用程序结束的时候，ECStack 才会被清空，所以程序结束之前， ECStack 最底部永远有个 globalContext：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("ECStack = [\n    globalContext\n];\n")])])]),n("p",[t._v("现在 JavaScript 遇到下面的这段代码了：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function fun3() {\n    console.log('fun3')\n}\n\nfunction fun2() {\n    fun3();\n}\n\nfunction fun1() {\n    fun2();\n}\n\nfun1();\n")])])]),n("p",[t._v("当执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出。知道了这样的工作原理，让我们来看看如何处理上面这段代码：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("// 伪代码\n\n// fun1()\nECStack.push(<fun1> functionContext);\n\n// fun1中竟然调用了fun2，还要创建fun2的执行上下文\nECStack.push(<fun2> functionContext);\n\n// 擦，fun2还调用了fun3！\nECStack.push(<fun3> functionContext);\n\n// fun3执行完毕\nECStack.pop();\n\n// fun2执行完毕\nECStack.pop();\n\n// fun1执行完毕\nECStack.pop();\n\n// javascript接着执行下面的代码，但是ECStack底层永远有个globalContext\n")])])]),n("h3",{attrs:{id:"解答思考题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#解答思考题"}},[t._v("#")]),t._v(" "),n("strong",[t._v("解答思考题")])]),t._v(" "),n("hr"),t._v(" "),n("p",[t._v("好啦，现在我们已经了解了执行上下文栈是如何处理执行上下文的，所以让我们看看上篇文章"),n("RouterLink",{attrs:{to:"/JavaScript/javascript2.html"}},[t._v("《JavaScript深入之词法作用域和动态作用域》")]),t._v("最后的问题：")],1),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('var scope = "global scope";\nfunction checkscope(){\n    var scope = "local scope";\n    function f(){\n        return scope;\n    }\n    return f();\n}\ncheckscope();\n')])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('var scope = "global scope";\nfunction checkscope(){\n    var scope = "local scope";\n    function f(){\n        return scope;\n    }\n    return f;\n}\ncheckscope()();    \n')])])]),n("p",[t._v("两段代码执行的结果一样，但是两段代码究竟有哪些不同呢？")]),t._v(" "),n("p",[t._v("答案就是执行上下文栈的变化不一样。")]),t._v(" "),n("p",[t._v("让我们模拟第一段代码：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("ECStack.push(<checkscope> functionContext);\nECStack.push(<f> functionContext);\nECStack.pop();\nECStack.pop();\n")])])]),n("p",[t._v("让我们模拟第二段代码：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("ECStack.push(<checkscope> functionContext);\nECStack.pop();\nECStack.push(<f> functionContext);\nECStack.pop();\n")])])]),n("p",[t._v("是不是有些不同呢？")]),t._v(" "),n("p",[t._v("当然了，这样概括的回答执行上下文栈的变化不同，是不是依然有一种意犹未尽的感觉呢，为了更详细讲解两个函数执行上的区别，我们需要探究一下执行上下文到底包含了哪些内容，所以欢迎阅读下一篇《JavaScript深入之变量对象》。")])])}),[],!1,null,null,null);n.default=s.exports}}]);