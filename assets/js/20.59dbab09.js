(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{442:function(n,e,a){"use strict";a.r(e);var t=a(2),s=Object(t.a)({},(function(){var n=this,e=n._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h1",{attrs:{id:"继承的多种方式和优缺点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#继承的多种方式和优缺点"}},[n._v("#")]),n._v(" 继承的多种方式和优缺点")]),n._v(" "),e("p",[e("strong",[n._v("原文链接："),e("a",{attrs:{href:"https://github.com/mqyqingfeng/Blog",target:"_blank",rel:"noopener noreferrer"}},[n._v("https://github.com/mqyqingfeng/Blog"),e("OutboundLink")],1)])]),n._v(" "),e("h3",{attrs:{id:"写在前面"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#写在前面"}},[n._v("#")]),n._v(" "),e("strong",[n._v("写在前面")])]),n._v(" "),e("hr"),n._v(" "),e("p",[n._v("本文讲解JavaScript各种继承方式和优缺点。")]),n._v(" "),e("p",[n._v("但是注意：")]),n._v(" "),e("p",[n._v("这篇文章更像是笔记，哎，再让我感叹一句：《JavaScript高级程序设计》写得真是太好了！")]),n._v(" "),e("h3",{attrs:{id:"_1-原型链继承"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-原型链继承"}},[n._v("#")]),n._v(" "),e("strong",[n._v("1.原型链继承")])]),n._v(" "),e("hr"),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("function Parent () {\n    this.name = 'kevin';\n}\n\nParent.prototype.getName = function () {\n    console.log(this.name);\n}\n\nfunction Child () {\n\n}\n\nChild.prototype = new Parent();\n\nvar child1 = new Child();\n\nconsole.log(child1.getName()) // kevin\n")])])]),e("p",[n._v("问题：")]),n._v(" "),e("p",[n._v("1.引用类型的属性被所有实例共享，举个例子：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('function Parent () {\n    this.names = [\'kevin\', \'daisy\'];\n}\n\nfunction Child () {\n\n}\n\nChild.prototype = new Parent();\n\nvar child1 = new Child();\n\nchild1.names.push(\'yayu\');\n\nconsole.log(child1.names); // ["kevin", "daisy", "yayu"]\n\nvar child2 = new Child();\n\nconsole.log(child2.names); // ["kevin", "daisy", "yayu"]\n')])])]),e("p",[n._v("2.在创建 Child 的实例时，不能向Parent传参")]),n._v(" "),e("h3",{attrs:{id:"_2-借用构造函数-经典继承"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-借用构造函数-经典继承"}},[n._v("#")]),n._v(" "),e("strong",[n._v("2.借用构造函数(经典继承)")])]),n._v(" "),e("hr"),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('function Parent () {\n    this.names = [\'kevin\', \'daisy\'];\n}\n\nfunction Child () {\n    Parent.call(this);\n}\n\nvar child1 = new Child();\n\nchild1.names.push(\'yayu\');\n\nconsole.log(child1.names); // ["kevin", "daisy", "yayu"]\n\nvar child2 = new Child();\n\nconsole.log(child2.names); // ["kevin", "daisy"]\n')])])]),e("p",[n._v("优点：")]),n._v(" "),e("p",[n._v("1.避免了引用类型的属性被所有实例共享")]),n._v(" "),e("p",[n._v("2.可以在 Child 中向 Parent 传参")]),n._v(" "),e("p",[n._v("举个例子：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("function Parent (name) {\n    this.name = name;\n}\n\nfunction Child (name) {\n    Parent.call(this, name);\n}\n\nvar child1 = new Child('kevin');\n\nconsole.log(child1.name); // kevin\n\nvar child2 = new Child('daisy');\n\nconsole.log(child2.name); // daisy\n")])])]),e("p",[n._v("缺点：")]),n._v(" "),e("p",[n._v("方法都在构造函数中定义，每次创建实例都会创建一遍方法。")]),n._v(" "),e("h3",{attrs:{id:"_3-组合继承"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-组合继承"}},[n._v("#")]),n._v(" "),e("strong",[n._v("3.组合继承")])]),n._v(" "),e("hr"),n._v(" "),e("p",[n._v("原型链继承和经典继承双剑合璧。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("function Parent (name) {\n    this.name = name;\n    this.colors = ['red', 'blue', 'green'];\n}\n\nParent.prototype.getName = function () {\n    console.log(this.name)\n}\n\nfunction Child (name, age) {\n\n    Parent.call(this, name);\n    \n    this.age = age;\n\n}\n\nChild.prototype = new Parent();\nChild.prototype.constructor = Child;\n\nvar child1 = new Child('kevin', '18');\n\nchild1.colors.push('black');\n\nconsole.log(child1.name); // kevin\nconsole.log(child1.age); // 18\nconsole.log(child1.colors); // [\"red\", \"blue\", \"green\", \"black\"]\n\nvar child2 = new Child('daisy', '20');\n\nconsole.log(child2.name); // daisy\nconsole.log(child2.age); // 20\nconsole.log(child2.colors); // [\"red\", \"blue\", \"green\"]\n")])])]),e("p",[n._v("优点：融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式。")]),n._v(" "),e("h3",{attrs:{id:"_4-原型式继承"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-原型式继承"}},[n._v("#")]),n._v(" "),e("strong",[n._v("4.原型式继承")])]),n._v(" "),e("hr"),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("function createObj(o) {\n    function F(){}\n    F.prototype = o;\n    return new F();\n}\n")])])]),e("p",[n._v("就是 ES5 Object.create 的模拟实现，将传入的对象作为创建的对象的原型。")]),n._v(" "),e("p",[n._v("缺点：")]),n._v(" "),e("p",[n._v("包含引用类型的属性值始终都会共享相应的值，这点跟原型链继承一样。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("var person = {\n    name: 'kevin',\n    friends: ['daisy', 'kelly']\n}\n\nvar person1 = createObj(person);\nvar person2 = createObj(person);\n\nperson1.name = 'person1';\nconsole.log(person2.name); // kevin\n\nperson1.friends.push('taylor');\nconsole.log(person2.friends); // [\"daisy\", \"kelly\", \"taylor\"]\n")])])]),e("p",[n._v("注意：修改person1.name的值，person2.name的值并未发生改变，并不是因为person1和person2有独立的 name 值，而是因为person1.name = 'person1'，给person1添加了 name 值，并非修改了原型上的 name 值。")]),n._v(" "),e("h3",{attrs:{id:"_5-寄生式继承"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-寄生式继承"}},[n._v("#")]),n._v(" "),e("strong",[n._v("5. 寄生式继承")])]),n._v(" "),e("hr"),n._v(" "),e("p",[n._v("创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("function createObj (o) {\n    var clone = Object.create(o);\n    clone.sayName = function () {\n        console.log('hi');\n    }\n    return clone;\n}\n")])])]),e("p",[n._v("缺点：跟借用构造函数模式一样，每次创建对象都会创建一遍方法。")]),n._v(" "),e("h3",{attrs:{id:"_6-寄生组合式继承"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6-寄生组合式继承"}},[n._v("#")]),n._v(" "),e("strong",[n._v("6. 寄生组合式继承")])]),n._v(" "),e("hr"),n._v(" "),e("p",[n._v("为了方便大家阅读，在这里重复一下组合继承的代码：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("function Parent (name) {\n    this.name = name;\n    this.colors = ['red', 'blue', 'green'];\n}\n\nParent.prototype.getName = function () {\n    console.log(this.name)\n}\n\nfunction Child (name, age) {\n    Parent.call(this, name);\n    this.age = age;\n}\n\nChild.prototype = new Parent();\n\nvar child1 = new Child('kevin', '18');\n\nconsole.log(child1)\n")])])]),e("p",[n._v("组合继承最大的缺点是会调用两次父构造函数。")]),n._v(" "),e("p",[n._v("一次是设置子类型实例的原型的时候：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("Child.prototype = new Parent();\n")])])]),e("p",[n._v("一次在创建子类型实例的时候：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("var child1 = new Child('kevin', '18');\n")])])]),e("p",[n._v("回想下 new 的模拟实现，其实在这句中，我们会执行：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("Parent.call(this, name);\n")])])]),e("p",[n._v("在这里，我们又会调用了一次 Parent 构造函数。")]),n._v(" "),e("p",[n._v("所以，在这个例子中，如果我们打印 child1 对象，我们会发现 Child.prototype 和 child1 都有一个属性为colors，属性值为['red', 'blue', 'green']。")]),n._v(" "),e("p",[n._v("那么我们该如何精益求精，避免这一次重复调用呢？")]),n._v(" "),e("p",[n._v("如果我们不使用 Child.prototype = new Parent() ，而是间接的让 Child.prototype 访问到 Parent.prototype 呢？")]),n._v(" "),e("p",[n._v("看看如何实现：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("function Parent (name) {\n    this.name = name;\n    this.colors = ['red', 'blue', 'green'];\n}\n\nParent.prototype.getName = function () {\n    console.log(this.name)\n}\n\nfunction Child (name, age) {\n    Parent.call(this, name);\n    this.age = age;\n}\n\n// 关键的三步\nvar F = function () {};\n\nF.prototype = Parent.prototype;\n\nChild.prototype = new F();\n\n\nvar child1 = new Child('kevin', '18');\n\nconsole.log(child1);\n")])])]),e("p",[n._v("最后我们封装一下这个继承方法：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("function object(o) {\n    function F() {}\n    F.prototype = o;\n    return new F();\n}\n\nfunction prototype(child, parent) {\n    var prototype = object(parent.prototype);\n    prototype.constructor = child;\n    child.prototype = prototype;\n}\n\n// 当我们使用的时候：\nprototype(Child, Parent);\n")])])]),e("p",[n._v("引用《JavaScript高级程序设计》中对寄生组合式继承的夸赞就是：")]),n._v(" "),e("p",[n._v("这种方式的高效率体现它只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用 instanceof 和 isPrototypeOf。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。")])])}),[],!1,null,null,null);e.default=s.exports}}]);