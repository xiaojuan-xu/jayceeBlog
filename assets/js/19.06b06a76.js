(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{433:function(n,e,a){"use strict";a.r(e);var s=a(2),t=Object(s.a)({},(function(){var n=this,e=n._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h1",{attrs:{id:"创建对象的多种方式以及优缺点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#创建对象的多种方式以及优缺点"}},[n._v("#")]),n._v(" 创建对象的多种方式以及优缺点")]),n._v(" "),e("p",[e("strong",[n._v("原文链接："),e("a",{attrs:{href:"https://github.com/mqyqingfeng/Blog",target:"_blank",rel:"noopener noreferrer"}},[n._v("https://github.com/mqyqingfeng/Blog"),e("OutboundLink")],1)])]),n._v(" "),e("h3",{attrs:{id:"写在前面"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#写在前面"}},[n._v("#")]),n._v(" "),e("strong",[n._v("写在前面")])]),n._v(" "),e("hr"),n._v(" "),e("p",[n._v("这篇文章讲解创建对象的各种方式，以及优缺点。")]),n._v(" "),e("p",[n._v("但是注意：")]),n._v(" "),e("p",[n._v("这篇文章更像是笔记，因为《JavaScript高级程序设计》写得真是太好了！")]),n._v(" "),e("h3",{attrs:{id:"_1-工厂模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-工厂模式"}},[n._v("#")]),n._v(" "),e("strong",[n._v("1. 工厂模式")])]),n._v(" "),e("hr"),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("function createPerson(name) {\n    var o = new Object();\n    o.name = name;\n    o.getName = function () {\n        console.log(this.name);\n    };\n\n    return o;\n}\n\nvar person1 = createPerson('kevin');\n")])])]),e("p",[n._v("缺点：对象无法识别，因为所有的实例都指向一个原型")]),n._v(" "),e("h3",{attrs:{id:"_2-构造函数模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-构造函数模式"}},[n._v("#")]),n._v(" "),e("strong",[n._v("2. 构造函数模式")])]),n._v(" "),e("hr"),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("function Person(name) {\n    this.name = name;\n    this.getName = function () {\n        console.log(this.name);\n    };\n}\n\nvar person1 = new Person('kevin');\n")])])]),e("p",[n._v("优点：实例可以识别为一个特定的类型")]),n._v(" "),e("p",[n._v("缺点：每次创建实例时，每个方法都要被创建一次")]),n._v(" "),e("h3",{attrs:{id:"_2-1-构造函数模式优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-构造函数模式优化"}},[n._v("#")]),n._v(" "),e("strong",[n._v("2.1 构造函数模式优化")])]),n._v(" "),e("hr"),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("function Person(name) {\n    this.name = name;\n    this.getName = getName;\n}\n\nfunction getName() {\n    console.log(this.name);\n}\n\nvar person1 = new Person('kevin');\n")])])]),e("p",[n._v("优点：解决了每个方法都要被重新创建的问题")]),n._v(" "),e("p",[n._v("缺点：这叫啥封装……")]),n._v(" "),e("h3",{attrs:{id:"_3-原型模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-原型模式"}},[n._v("#")]),n._v(" "),e("strong",[n._v("3. 原型模式")])]),n._v(" "),e("hr"),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("function Person(name) {\n\n}\n\nPerson.prototype.name = 'keivn';\nPerson.prototype.getName = function () {\n    console.log(this.name);\n};\n\nvar person1 = new Person();\n")])])]),e("p",[n._v("优点：方法不会重新创建")]),n._v(" "),e("p",[n._v("缺点：1. 所有的属性和方法都共享 2. 不能初始化参数")]),n._v(" "),e("h3",{attrs:{id:"_3-1-原型模式优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-原型模式优化"}},[n._v("#")]),n._v(" "),e("strong",[n._v("3.1 原型模式优化")])]),n._v(" "),e("hr"),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("function Person(name) {\n\n}\n\nPerson.prototype = {\n    name: 'kevin',\n    getName: function () {\n        console.log(this.name);\n    }\n};\n\nvar person1 = new Person();\n")])])]),e("p",[n._v("优点：封装性好了一点")]),n._v(" "),e("p",[n._v("缺点：重写了原型，丢失了constructor属性")]),n._v(" "),e("h3",{attrs:{id:"_3-2-原型模式优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-原型模式优化"}},[n._v("#")]),n._v(" "),e("strong",[n._v("3.2 原型模式优化")])]),n._v(" "),e("hr"),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("function Person(name) {\n\n}\n\nPerson.prototype = {\n    constructor: Person,\n    name: 'kevin',\n    getName: function () {\n        console.log(this.name);\n    }\n};\n\nvar person1 = new Person();\n")])])]),e("p",[n._v("优点：实例可以通过constructor属性找到所属构造函数")]),n._v(" "),e("p",[n._v("缺点：原型模式该有的缺点还是有")]),n._v(" "),e("h3",{attrs:{id:"_4-组合模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-组合模式"}},[n._v("#")]),n._v(" "),e("strong",[n._v("4. 组合模式")])]),n._v(" "),e("hr"),n._v(" "),e("p",[n._v("构造函数模式与原型模式双剑合璧。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("function Person(name) {\n    this.name = name;\n}\n\nPerson.prototype = {\n    constructor: Person,\n    getName: function () {\n        console.log(this.name);\n    }\n};\n\nvar person1 = new Person();\n")])])]),e("p",[n._v("优点：该共享的共享，该私有的私有，使用最广泛的方式")]),n._v(" "),e("p",[n._v("缺点：有的人就是希望全部都写在一起，即更好的封装性")]),n._v(" "),e("h3",{attrs:{id:"_4-1-动态原型模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-动态原型模式"}},[n._v("#")]),n._v(" "),e("strong",[n._v("4.1 动态原型模式")])]),n._v(" "),e("hr"),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('function Person(name) {\n    this.name = name;\n    if (typeof this.getName != "function") {\n        Person.prototype.getName = function () {\n            console.log(this.name);\n        }\n    }\n}\n\nvar person1 = new Person();\n')])])]),e("p",[n._v("注意：使用动态原型模式时，不能用对象字面量重写原型")]),n._v(" "),e("p",[n._v("解释下为什么：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("function Person(name) {\n    this.name = name;\n    if (typeof this.getName != \"function\") {\n        Person.prototype = {\n            constructor: Person,\n            getName: function () {\n                console.log(this.name);\n            }\n        }\n    }\n}\n\nvar person1 = new Person('kevin');\nvar person2 = new Person('daisy');\n\n// 报错 并没有该方法\nperson1.getName();\n\n// 注释掉上面的代码，这句是可以执行的。\nperson2.getName();\n")])])]),e("p",[n._v("为了解释这个问题，假设开始执行var person1 = new Person('kevin')。")]),n._v(" "),e("p",[n._v("如果对 new 和 apply 的底层执行过程不是很熟悉，可以阅读底部相关链接中的文章。")]),n._v(" "),e("p",[n._v("我们回顾下 new 的实现步骤：")]),n._v(" "),e("ol",[e("li",[n._v("首先新建一个对象")]),n._v(" "),e("li",[n._v("然后将对象的原型指向 Person.prototype")]),n._v(" "),e("li",[n._v("然后 Person.apply(obj)")]),n._v(" "),e("li",[n._v("返回这个对象")])]),n._v(" "),e("p",[n._v("注意这个时候，回顾下 apply 的实现步骤，会执行 obj.Person 方法，这个时候就会执行 if 语句里的内容，注意构造函数的 prototype 属性指向了实例的原型，使用字面量方式直接覆盖 Person.prototype，并不会更改实例的原型的值，person1 依然是指向了以前的原型，而不是 Person.prototype。而之前的原型是没有 getName 方法的，所以就报错了！")]),n._v(" "),e("p",[n._v("如果你就是想用字面量方式写代码，可以尝试下这种：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("function Person(name) {\n    this.name = name;\n    if (typeof this.getName != \"function\") {\n        Person.prototype = {\n            constructor: Person,\n            getName: function () {\n                console.log(this.name);\n            }\n        }\n\n        return new Person(name);\n    }\n}\n\nvar person1 = new Person('kevin');\nvar person2 = new Person('daisy');\n\nperson1.getName(); // kevin\nperson2.getName();  // daisy\n")])])]),e("h3",{attrs:{id:"_5-1-寄生构造函数模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-寄生构造函数模式"}},[n._v("#")]),n._v(" "),e("strong",[n._v("5.1 寄生构造函数模式")])]),n._v(" "),e("hr"),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("function Person(name) {\n\n    var o = new Object();\n    o.name = name;\n    o.getName = function () {\n        console.log(this.name);\n    };\n\n    return o;\n\n}\n\nvar person1 = new Person('kevin');\nconsole.log(person1 instanceof Person) // false\nconsole.log(person1 instanceof Object)  // true\n")])])]),e("p",[n._v("寄生构造函数模式，我个人认为应该这样读：")]),n._v(" "),e("p",[n._v("寄生-构造函数-模式，也就是说寄生在构造函数的一种方法。")]),n._v(" "),e("p",[n._v("也就是说打着构造函数的幌子挂羊头卖狗肉，你看创建的实例使用 instanceof 都无法指向构造函数！")]),n._v(" "),e("p",[n._v("这样方法可以在特殊情况下使用。比如我们想创建一个具有额外方法的特殊数组，但是又不想直接修改Array构造函数，我们可以这样写：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("function SpecialArray() {\n    var values = new Array();\n\n    for (var i = 0, len = arguments.length; i < len; i++) {\n        values.push(arguments[i]);\n    }\n\n    values.toPipedString = function () {\n        return this.join(\"|\");\n    };\n    return values;\n}\n\nvar colors = new SpecialArray('red', 'blue', 'green');\nvar colors2 = SpecialArray('red2', 'blue2', 'green2');\n\n\nconsole.log(colors);\nconsole.log(colors.toPipedString()); // red|blue|green\n\nconsole.log(colors2);\nconsole.log(colors2.toPipedString()); // red2|blue2|green2\n")])])]),e("p",[n._v("你会发现，其实所谓的寄生构造函数模式就是比工厂模式在创建对象的时候，多使用了一个new，实际上两者的结果是一样的。")]),n._v(" "),e("p",[n._v("但是作者可能是希望能像使用普通 Array 一样使用 SpecialArray，虽然把 SpecialArray 当成函数也一样能用，但是这并不是作者的本意，也变得不优雅。")]),n._v(" "),e("p",[n._v("在可以使用其他模式的情况下，不要使用这种模式。")]),n._v(" "),e("p",[n._v("但是值得一提的是，上面例子中的循环：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("for (var i = 0, len = arguments.length; i < len; i++) {\n    values.push(arguments[i]);\n}\n")])])]),e("p",[n._v("可以替换成：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("values.push.apply(values, arguments);\n")])])]),e("h3",{attrs:{id:"_5-2-稳妥构造函数模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-稳妥构造函数模式"}},[n._v("#")]),n._v(" "),e("strong",[n._v("5.2 稳妥构造函数模式")])]),n._v(" "),e("hr"),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("function person(name){\n    var o = new Object();\n    o.sayName = function(){\n        console.log(name);\n    };\n    return o;\n}\n\nvar person1 = person('kevin');\n\nperson1.sayName(); // kevin\n\nperson1.name = \"daisy\";\n\nperson1.sayName(); // kevin\n\nconsole.log(person1.name); // daisy\n")])])]),e("p",[n._v("所谓稳妥对象，指的是没有公共属性，而且其方法也不引用 this 的对象。")]),n._v(" "),e("p",[n._v("与寄生构造函数模式有两点不同：")]),n._v(" "),e("ol",[e("li",[n._v("新创建的实例方法不引用 this")]),n._v(" "),e("li",[n._v("不使用 new 操作符调用构造函数")])]),n._v(" "),e("p",[n._v("稳妥对象最适合在一些安全的环境中。")]),n._v(" "),e("p",[n._v("稳妥构造函数模式也跟工厂模式一样，无法识别对象所属类型。")])])}),[],!1,null,null,null);e.default=t.exports}}]);